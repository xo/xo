// Package models contains generated code for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"strings"
)

var (
	// logf is used by generated code to log SQL queries.
	logf = func(string, ...interface{}) {}
	// errf is used by generated code to log SQL errors.
	errf = func(string, ...interface{}) {}
)

// logerror logs the error and returns it.
func logerror(err error) error {
	errf("ERROR: %v", err)
	return err
}

// Logf logs a message using the package logger.
func Logf(s string, v ...interface{}) {
	logf(s, v...)
}

// SetLogger sets the package logger. Valid logger types:
//
//	io.Writer
//	func(string, ...interface{}) (int, error) // fmt.Printf
//	func(string, ...interface{}) // log.Printf
func SetLogger(logger interface{}) {
	logf = convLogger(logger)
}

// Errorf logs an error message using the package error logger.
func Errorf(s string, v ...interface{}) {
	errf(s, v...)
}

// SetErrorLogger sets the package error logger. Valid logger types:
//
//	io.Writer
//	func(string, ...interface{}) (int, error) // fmt.Printf
//	func(string, ...interface{}) // log.Printf
func SetErrorLogger(logger interface{}) {
	errf = convLogger(logger)
}

// convLogger converts logger to the standard logger interface.
func convLogger(logger interface{}) func(string, ...interface{}) {
	switch z := logger.(type) {
	case io.Writer:
		return func(s string, v ...interface{}) {
			fmt.Fprintf(z, s, v...)
		}
	case func(string, ...interface{}) (int, error): // fmt.Printf
		return func(s string, v ...interface{}) {
			_, _ = z(s, v...)
		}
	case func(string, ...interface{}): // log.Printf
		return z
	}
	panic(fmt.Sprintf("unsupported logger type %T", logger))
}

// DB is the common interface for database operations that can be used with
// types from schema 'public'.
//
// This works with both [database/sql.DB] and [database/sql.Tx].
type DB interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// Error is an error.
type Error string

// Error satisfies the error interface.
func (err Error) Error() string {
	return string(err)
}

// Error values.
const (
	// ErrAlreadyExists is the already exists error.
	ErrAlreadyExists Error = "already exists"
	// ErrDoesNotExist is the does not exist error.
	ErrDoesNotExist Error = "does not exist"
	// ErrMarkedForDeletion is the marked for deletion error.
	ErrMarkedForDeletion Error = "marked for deletion"
)

// ErrInsertFailed is the insert failed error.
type ErrInsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrInsertFailed) Error() string {
	return fmt.Sprintf("insert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrInsertFailed) Unwrap() error {
	return err.Err
}

// ErrUpdateFailed is the update failed error.
type ErrUpdateFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpdateFailed) Error() string {
	return fmt.Sprintf("update failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpdateFailed) Unwrap() error {
	return err.Err
}

// ErrUpsertFailed is the upsert failed error.
type ErrUpsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpsertFailed) Error() string {
	return fmt.Sprintf("upsert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpsertFailed) Unwrap() error {
	return err.Err
}

// PostgresViewCreate creates a view for introspection.
func PostgresViewCreate(ctx context.Context, db DB, schema, id string, query []string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`CREATE TEMPORARY VIEW ` + id + ` AS ` + strings.Join(query, "\n")
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// PostgresViewSchema retrieves the schema for a view created for introspection.
func PostgresViewSchema(ctx context.Context, db DB, id string) (string, error) {
	// query
	sqlstr := `SELECT ` +
		`n.nspname ` + // ::varchar AS schema_name
		`FROM pg_class c ` +
		`JOIN pg_namespace n ON n.oid = c.relnamespace ` +
		`WHERE n.nspname LIKE 'pg_temp%' ` +
		`AND c.relname = $1`
	// run
	logf(sqlstr, id)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}

// PostgresViewDrop drops a view created for introspection.
func PostgresViewDrop(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`DROP VIEW ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// PostgresSchema retrieves the schema.
func PostgresSchema(ctx context.Context, db DB) (string, error) {
	// query
	const sqlstr = `SELECT ` +
		`CURRENT_SCHEMA()` // ::varchar AS schema_name
	// run
	logf(sqlstr)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}

// MysqlViewCreate creates a view for introspection.
func MysqlViewCreate(ctx context.Context, db DB, schema, id string, query []string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`CREATE VIEW ` + id + ` AS ` + strings.Join(query, "\n")
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// MysqlViewDrop drops a view created for introspection.
func MysqlViewDrop(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`DROP VIEW ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// MysqlSchema retrieves the schema.
func MysqlSchema(ctx context.Context, db DB) (string, error) {
	// query
	const sqlstr = `SELECT ` +
		`SCHEMA() AS schema_name`
	// run
	logf(sqlstr)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}

// Sqlite3ViewCreate creates a view for introspection.
func Sqlite3ViewCreate(ctx context.Context, db DB, schema, id string, query []string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`CREATE TEMPORARY VIEW ` + id + ` AS ` + strings.Join(query, "\n")
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// Sqlite3ViewDrop drops a view created for introspection.
func Sqlite3ViewDrop(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`DROP VIEW ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// Sqlite3Schema retrieves the schema.
func Sqlite3Schema(ctx context.Context, db DB) (string, error) {
	// query
	const sqlstr = `SELECT ` +
		`REPLACE(file, RTRIM(file, REPLACE(file, '/', '')), '') AS schema_name ` +
		`FROM pragma_database_list()`
	// run
	logf(sqlstr)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}

// SqlserverViewCreate creates a view for introspection.
func SqlserverViewCreate(ctx context.Context, db DB, schema, id string, query []string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`CREATE VIEW ` + id + ` AS ` + strings.Join(query, "\n")
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// SqlserverViewDrop drops a view created for introspection.
func SqlserverViewDrop(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`DROP VIEW ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// SqlserverSchema retrieves the schema.
func SqlserverSchema(ctx context.Context, db DB) (string, error) {
	// query
	const sqlstr = `SELECT ` +
		`SCHEMA_NAME() AS schema_name`
	// run
	logf(sqlstr)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}

// OracleViewCreate creates a view for introspection.
func OracleViewCreate(ctx context.Context, db DB, schema, id string, query []string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`CREATE GLOBAL TEMPORARY TABLE ` + id + ` ON COMMIT PRESERVE ROWS AS ` + strings.Join(query, "\n")
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// OracleViewTruncate truncates a view created for introspection.
func OracleViewTruncate(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`TRUNCATE TABLE ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// OracleViewDrop drops a view created for introspection.
func OracleViewDrop(ctx context.Context, db DB, schema, id string) (sql.Result, error) {
	// query
	sqlstr := `/* ` + schema + ` */ ` +
		`DROP TABLE ` + id
	// run
	logf(sqlstr)
	return db.ExecContext(ctx, sqlstr)
}

// OracleSchema retrieves the schema.
func OracleSchema(ctx context.Context, db DB) (string, error) {
	// query
	const sqlstr = `SELECT ` +
		`LOWER(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')) AS schema_name ` +
		`FROM dual`
	// run
	logf(sqlstr)
	var schemaName string
	if err := db.QueryRowContext(ctx, sqlstr).Scan(&schemaName); err != nil {
		return "", logerror(err)
	}
	return schemaName, nil
}
