---
# Generated by xo.
schemas:
  - type: postgres
    name: information_schema
    procs:
    - type: function
      name: _pg_char_max_length
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE WHEN $2 = -1 /* default typmod */
               THEN null
               WHEN $1 IN (1042, 1043) /* char, varchar */
               THEN $2 - 4
               WHEN $1 IN (1560, 1562) /* bit, varbit */
               THEN $2
               ELSE null
          END
    - type: function
      name: _pg_char_octet_length
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE WHEN $1 IN (25, 1042, 1043) /* text, char, varchar */
               THEN CASE WHEN $2 = -1 /* default typmod */
                         THEN CAST(2^30 AS integer)
                         ELSE information_schema._pg_char_max_length($1, $2) *
                              pg_catalog.pg_encoding_max_length((SELECT encoding FROM pg_catalog.pg_database WHERE datname = pg_catalog.current_database()))
                    END
               ELSE null
          END
    - type: function
      name: _pg_datetime_precision
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE WHEN $1 IN (1082) /* date */
                   THEN 0
               WHEN $1 IN (1083, 1114, 1184, 1266) /* time, timestamp, same + tz */
                   THEN CASE WHEN $2 < 0 THEN 6 ELSE $2 END
               WHEN $1 IN (1186) /* interval */
                   THEN CASE WHEN $2 < 0 OR $2 & 65535 = 65535 THEN 6 ELSE $2 & 65535 END
               ELSE null
          END
    - type: function
      name: _pg_expandarray
      params:
      - name: p0
        datatype:
          type: anyarray
      return:
      - name: x
        datatype:
          type: anyelement
      - name: n
        datatype:
          type: integer
      definition: |-
        select $1[s], s - pg_catalog.array_lower($1,1) + 1
                from pg_catalog.generate_series(pg_catalog.array_lower($1,1),
                                                pg_catalog.array_upper($1,1),
                                                1) as g(s)
    - type: function
      name: _pg_index_position
      params:
      - name: p0
        datatype:
          type: oid
      - name: p1
        datatype:
          type: smallint
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT (ss.a).n FROM
          (SELECT information_schema._pg_expandarray(indkey) AS a
           FROM pg_catalog.pg_index WHERE indexrelid = $1) ss
          WHERE (ss.a).x = $2;
    - type: function
      name: _pg_interval_type
      params:
      - name: typid
        datatype:
          type: oid
      - name: mod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: text
      definition: "SELECT\n  CASE WHEN $1 IN (1186) /* interval */\n           THEN pg_catalog.upper(substring(pg_catalog.format_type($1, $2) from 'interval[()0-9]* #\"%#\"' for '#'))\n       ELSE null\n  END"
    - type: function
      name: _pg_numeric_precision
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE $1
                 WHEN 21 /*int2*/ THEN 16
                 WHEN 23 /*int4*/ THEN 32
                 WHEN 20 /*int8*/ THEN 64
                 WHEN 1700 /*numeric*/ THEN
                      CASE WHEN $2 = -1
                           THEN null
                           ELSE (($2 - 4) >> 16) & 65535
                           END
                 WHEN 700 /*float4*/ THEN 24 /*FLT_MANT_DIG*/
                 WHEN 701 /*float8*/ THEN 53 /*DBL_MANT_DIG*/
                 ELSE null
          END
    - type: function
      name: _pg_numeric_precision_radix
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE WHEN $1 IN (21, 23, 20, 700, 701) THEN 2
               WHEN $1 IN (1700) THEN 10
               ELSE null
          END
    - type: function
      name: _pg_numeric_scale
      params:
      - name: typid
        datatype:
          type: oid
      - name: typmod
        datatype:
          type: integer
      return:
      - name: r0
        datatype:
          type: integer
      definition: |-
        SELECT
          CASE WHEN $1 IN (21, 23, 20) THEN 0
               WHEN $1 IN (1700) THEN
                    CASE WHEN $2 = -1
                         THEN null
                         ELSE ($2 - 4) & 65535
                         END
               ELSE null
          END
    - type: function
      name: _pg_truetypid
      params:
      - name: p0
        datatype:
          type: pg_attribute
      - name: p1
        datatype:
          type: pg_type
      return:
      - name: r0
        datatype:
          type: oid
      definition: |
        SELECT CASE WHEN $2.typtype = 'd' THEN $2.typbasetype ELSE $1.atttypid END
    - type: function
      name: _pg_truetypmod
      params:
      - name: p0
        datatype:
          type: pg_attribute
      - name: p1
        datatype:
          type: pg_type
      return:
      - name: r0
        datatype:
          type: integer
      definition: |
        SELECT CASE WHEN $2.typtype = 'd' THEN $2.typtypmod ELSE $1.atttypmod END
    tables:
    - type: table
      name: sql_features
      columns:
      - name: tableoid
        datatype:
          type: oid
      - name: cmax
        datatype:
          type: cid
      - name: xmax
        datatype:
          type: xid
      - name: cmin
        datatype:
          type: cid
      - name: xmin
        datatype:
          type: xid
      - name: ctid
        datatype:
          type: tid
      - name: feature_id
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: feature_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: sub_feature_id
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: sub_feature_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_supported
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_verified_by
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: comments
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
    - type: table
      name: sql_implementation_info
      columns:
      - name: tableoid
        datatype:
          type: oid
      - name: cmax
        datatype:
          type: cid
      - name: xmax
        datatype:
          type: xid
      - name: cmin
        datatype:
          type: cid
      - name: xmin
        datatype:
          type: xid
      - name: ctid
        datatype:
          type: tid
      - name: implementation_info_id
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: implementation_info_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: integer_value
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_value
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: comments
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
    - type: table
      name: sql_parts
      columns:
      - name: tableoid
        datatype:
          type: oid
      - name: cmax
        datatype:
          type: cid
      - name: xmax
        datatype:
          type: xid
      - name: cmin
        datatype:
          type: cid
      - name: xmin
        datatype:
          type: xid
      - name: ctid
        datatype:
          type: tid
      - name: feature_id
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: feature_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_supported
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_verified_by
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: comments
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
    - type: table
      name: sql_sizing
      columns:
      - name: tableoid
        datatype:
          type: oid
      - name: cmax
        datatype:
          type: cid
      - name: xmax
        datatype:
          type: xid
      - name: cmin
        datatype:
          type: cid
      - name: xmin
        datatype:
          type: xid
      - name: ctid
        datatype:
          type: tid
      - name: sizing_id
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: sizing_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: supported_value
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: comments
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
    views:
    - type: view
      name: _pg_foreign_data_wrappers
      columns:
      - name: oid
        datatype:
          type: oid
          nullable: true
      - name: fdwowner
        datatype:
          type: oid
          nullable: true
      - name: fdwoptions
        datatype:
          type: text
          nullable: true
          array: true
      - name: foreign_data_wrapper_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_language
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT w.oid,
            w.fdwowner,
            w.fdwoptions,
            (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
            (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name,
            (u.rolname)::information_schema.sql_identifier AS authorization_identifier,
            ('c'::character varying)::information_schema.character_data AS foreign_data_wrapper_language
           FROM pg_foreign_data_wrapper w,
            pg_authid u
          WHERE ((u.oid = w.fdwowner) AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text)));
    - type: view
      name: _pg_foreign_servers
      columns:
      - name: oid
        datatype:
          type: oid
          nullable: true
      - name: srvoptions
        datatype:
          type: text
          nullable: true
          array: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: foreign_server_version
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT s.oid,
            s.srvoptions,
            (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
            (s.srvname)::information_schema.sql_identifier AS foreign_server_name,
            (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
            (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name,
            (s.srvtype)::information_schema.character_data AS foreign_server_type,
            (s.srvversion)::information_schema.character_data AS foreign_server_version,
            (u.rolname)::information_schema.sql_identifier AS authorization_identifier
           FROM pg_foreign_server s,
            pg_foreign_data_wrapper w,
            pg_authid u
          WHERE ((w.oid = s.srvfdw) AND (u.oid = s.srvowner) AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)));
    - type: view
      name: _pg_foreign_table_columns
      columns:
      - name: nspname
        datatype:
          type: name
          nullable: true
      - name: relname
        datatype:
          type: name
          nullable: true
      - name: attname
        datatype:
          type: name
          nullable: true
      - name: attfdwoptions
        datatype:
          type: text
          nullable: true
          array: true
      manual: true
      definition: |-
        SELECT n.nspname,
            c.relname,
            a.attname,
            a.attfdwoptions
           FROM pg_foreign_table t,
            pg_authid u,
            pg_namespace n,
            pg_class c,
            pg_attribute a
          WHERE ((u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (a.attrelid = c.oid) AND (a.attnum > 0));
    - type: view
      name: _pg_foreign_tables
      columns:
      - name: foreign_table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ftoptions
        datatype:
          type: text
          nullable: true
          array: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS foreign_table_catalog,
            (n.nspname)::information_schema.sql_identifier AS foreign_table_schema,
            (c.relname)::information_schema.sql_identifier AS foreign_table_name,
            t.ftoptions,
            (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
            (s.srvname)::information_schema.sql_identifier AS foreign_server_name,
            (u.rolname)::information_schema.sql_identifier AS authorization_identifier
           FROM pg_foreign_table t,
            pg_foreign_server s,
            pg_foreign_data_wrapper w,
            pg_authid u,
            pg_namespace n,
            pg_class c
          WHERE ((w.oid = s.srvfdw) AND (u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (s.oid = t.ftserver));
    - type: view
      name: _pg_user_mappings
      columns:
      - name: oid
        datatype:
          type: oid
          nullable: true
      - name: umoptions
        datatype:
          type: text
          nullable: true
          array: true
      - name: umuser
        datatype:
          type: oid
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: srvowner
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT um.oid,
            um.umoptions,
            um.umuser,
            (COALESCE(u.rolname, 'PUBLIC'::name))::information_schema.sql_identifier AS authorization_identifier,
            s.foreign_server_catalog,
            s.foreign_server_name,
            s.authorization_identifier AS srvowner
           FROM (pg_user_mapping um
             LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
            information_schema._pg_foreign_servers s
          WHERE (s.oid = um.umserver);
    - type: view
      name: administrable_role_authorizations
      columns:
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: role_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT applicable_roles.grantee,
            applicable_roles.role_name,
            applicable_roles.is_grantable
           FROM information_schema.applicable_roles
          WHERE ((applicable_roles.is_grantable)::text = 'YES'::text);
    - type: view
      name: applicable_roles
      columns:
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: role_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (a.rolname)::information_schema.sql_identifier AS grantee,
            (b.rolname)::information_schema.sql_identifier AS role_name,
            (
                CASE
                    WHEN m.admin_option THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ((pg_auth_members m
             JOIN pg_authid a ON ((m.member = a.oid)))
             JOIN pg_authid b ON ((m.roleid = b.oid)))
          WHERE pg_has_role(a.oid, 'USAGE'::text);
    - type: view
      name: attributes
      columns:
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: attribute_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordinal_position
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: attribute_default
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_nullable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: attribute_udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: attribute_udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: attribute_udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_derived_reference_attribute
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nc.nspname)::information_schema.sql_identifier AS udt_schema,
            (c.relname)::information_schema.sql_identifier AS udt_name,
            (a.attname)::information_schema.sql_identifier AS attribute_name,
            (a.attnum)::information_schema.cardinal_number AS ordinal_position,
            (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data AS attribute_default,
            (
                CASE
                    WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
                    ELSE 'YES'::text
                END)::information_schema.yes_or_no AS is_nullable,
            (
                CASE
                    WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                    WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
                    ELSE 'USER-DEFINED'::text
                END)::information_schema.character_data AS data_type,
            (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length,
            (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (
                CASE
                    WHEN (nco.nspname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS collation_catalog,
            (nco.nspname)::information_schema.sql_identifier AS collation_schema,
            (co.collname)::information_schema.sql_identifier AS collation_name,
            (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision,
            (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
            (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale,
            (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision,
            (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (current_database())::information_schema.sql_identifier AS attribute_udt_catalog,
            (nt.nspname)::information_schema.sql_identifier AS attribute_udt_schema,
            (t.typname)::information_schema.sql_identifier AS attribute_udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            (a.attnum)::information_schema.sql_identifier AS dtd_identifier,
            ('NO'::character varying)::information_schema.yes_or_no AS is_derived_reference_attribute
           FROM ((((pg_attribute a
             LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
             JOIN (pg_class c
             JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
             JOIN (pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
             LEFT JOIN (pg_collation co
             JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
          WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = 'c'::"char") AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text)));
    - type: view
      name: character_sets
      columns:
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_repertoire
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: form_of_use
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_collate_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_collate_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_collate_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (getdatabaseencoding())::information_schema.sql_identifier AS character_set_name,
            (
                CASE
                    WHEN (getdatabaseencoding() = 'UTF8'::name) THEN 'UCS'::name
                    ELSE getdatabaseencoding()
                END)::information_schema.sql_identifier AS character_repertoire,
            (getdatabaseencoding())::information_schema.sql_identifier AS form_of_use,
            (current_database())::information_schema.sql_identifier AS default_collate_catalog,
            (nc.nspname)::information_schema.sql_identifier AS default_collate_schema,
            (c.collname)::information_schema.sql_identifier AS default_collate_name
           FROM (pg_database d
             LEFT JOIN (pg_collation c
             JOIN pg_namespace nc ON ((c.collnamespace = nc.oid))) ON (((d.datcollate = c.collcollate) AND (d.datctype = c.collctype))))
          WHERE (d.datname = current_database())
          ORDER BY (char_length((c.collname)::text)) DESC, c.collname
         LIMIT 1;
    - type: view
      name: check_constraint_routine_usage
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
            (c.conname)::information_schema.sql_identifier AS constraint_name,
            (current_database())::information_schema.sql_identifier AS specific_catalog,
            (np.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name
           FROM pg_namespace nc,
            pg_constraint c,
            pg_depend d,
            pg_proc p,
            pg_namespace np
          WHERE ((nc.oid = c.connamespace) AND (c.contype = 'c'::"char") AND (c.oid = d.objid) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.refobjid = p.oid) AND (d.refclassid = ('pg_proc'::regclass)::oid) AND (p.pronamespace = np.oid) AND pg_has_role(p.proowner, 'USAGE'::text));
    - type: view
      name: check_constraints
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: check_clause
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (rs.nspname)::information_schema.sql_identifier AS constraint_schema,
            (con.conname)::information_schema.sql_identifier AS constraint_name,
            ("substring"(pg_get_constraintdef(con.oid), 7))::information_schema.character_data AS check_clause
           FROM (((pg_constraint con
             LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace)))
             LEFT JOIN pg_class c ON ((c.oid = con.conrelid)))
             LEFT JOIN pg_type t ON ((t.oid = con.contypid)))
          WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text) AND (con.contype = 'c'::"char"))
        UNION
         SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (n.nspname)::information_schema.sql_identifier AS constraint_schema,
            (((((((n.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name,
            (((a.attname)::text || ' IS NOT NULL'::text))::information_schema.character_data AS check_clause
           FROM pg_namespace n,
            pg_class r,
            pg_attribute a
          WHERE ((n.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (a.attnum > 0) AND (NOT a.attisdropped) AND a.attnotnull AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE'::text));
    - type: view
      name: collation_character_set_applicability
      columns:
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS collation_catalog,
            (nc.nspname)::information_schema.sql_identifier AS collation_schema,
            (c.collname)::information_schema.sql_identifier AS collation_name,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (getdatabaseencoding())::information_schema.sql_identifier AS character_set_name
           FROM pg_collation c,
            pg_namespace nc
          WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
                   FROM pg_database
                  WHERE (pg_database.datname = current_database()))])));
    - type: view
      name: collations
      columns:
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: pad_attribute
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS collation_catalog,
            (nc.nspname)::information_schema.sql_identifier AS collation_schema,
            (c.collname)::information_schema.sql_identifier AS collation_name,
            ('NO PAD'::character varying)::information_schema.character_data AS pad_attribute
           FROM pg_collation c,
            pg_namespace nc
          WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
                   FROM pg_database
                  WHERE (pg_database.datname = current_database()))])));
    - type: view
      name: column_column_usage
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: dependent_column
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (n.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (ac.attname)::information_schema.sql_identifier AS column_name,
            (ad.attname)::information_schema.sql_identifier AS dependent_column
           FROM pg_namespace n,
            pg_class c,
            pg_depend d,
            pg_attribute ac,
            pg_attribute ad
          WHERE ((n.oid = c.relnamespace) AND (c.oid = ac.attrelid) AND (c.oid = ad.attrelid) AND (d.classid = ('pg_class'::regclass)::oid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.objid = d.refobjid) AND (c.oid = d.objid) AND (d.objsubid = ad.attnum) AND (d.refobjsubid = ac.attnum) AND (ad.attgenerated <> ''::"char") AND pg_has_role(c.relowner, 'USAGE'::text));
    - type: view
      name: column_domain_usage
      columns:
      - name: domain_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS domain_catalog,
            (nt.nspname)::information_schema.sql_identifier AS domain_schema,
            (t.typname)::information_schema.sql_identifier AS domain_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (a.attname)::information_schema.sql_identifier AS column_name
           FROM pg_type t,
            pg_namespace nt,
            pg_class c,
            pg_namespace nc,
            pg_attribute a
          WHERE ((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid) AND (a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (t.typtype = 'd'::"char") AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (a.attnum > 0) AND (NOT a.attisdropped) AND pg_has_role(t.typowner, 'USAGE'::text));
    - type: view
      name: column_options
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_value
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (c.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (c.attname)::information_schema.sql_identifier AS column_name,
            ((pg_options_to_table(c.attfdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
            ((pg_options_to_table(c.attfdwoptions)).option_value)::information_schema.character_data AS option_value
           FROM information_schema._pg_foreign_table_columns c;
    - type: view
      name: column_privileges
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (x.relname)::information_schema.sql_identifier AS table_name,
            (x.attname)::information_schema.sql_identifier AS column_name,
            (x.prtype)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pr_c.grantor,
                    pr_c.grantee,
                    a.attname,
                    pr_c.relname,
                    pr_c.relnamespace,
                    pr_c.prtype,
                    pr_c.grantable,
                    pr_c.relowner
                   FROM ( SELECT pg_class.oid,
                            pg_class.relname,
                            pg_class.relnamespace,
                            pg_class.relowner,
                            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
                            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
                            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
                           FROM pg_class
                          WHERE (pg_class.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),
                    pg_attribute a
                  WHERE ((a.attrelid = pr_c.oid) AND (a.attnum > 0) AND (NOT a.attisdropped))
                UNION
                 SELECT pr_a.grantor,
                    pr_a.grantee,
                    pr_a.attname,
                    c.relname,
                    c.relnamespace,
                    pr_a.prtype,
                    pr_a.grantable,
                    c.relowner
                   FROM ( SELECT a.attrelid,
                            a.attname,
                            (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantor AS grantor,
                            (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantee AS grantee,
                            (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).privilege_type AS privilege_type,
                            (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).is_grantable AS is_grantable
                           FROM (pg_attribute a
                             JOIN pg_class cc ON ((a.attrelid = cc.oid)))
                          WHERE ((a.attnum > 0) AND (NOT a.attisdropped))) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),
                    pg_class c
                  WHERE ((pr_a.attrelid = c.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])))) x,
            pg_namespace nc,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((x.relnamespace = nc.oid) AND (x.grantee = grantee.oid) AND (x.grantor = u_grantor.oid) AND (x.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)));
    - type: view
      name: column_udt_usage
      columns:
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
            (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema,
            (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (a.attname)::information_schema.sql_identifier AS column_name
           FROM pg_attribute a,
            pg_class c,
            pg_namespace nc,
            ((pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             LEFT JOIN (pg_type bt
             JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
          WHERE ((a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (nc.oid = c.relnamespace) AND (a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text));
    - type: view
      name: columns
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordinal_position
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: column_default
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_nullable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_self_referencing
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_identity
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: identity_generation
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: identity_start
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: identity_increment
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: identity_maximum
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: identity_minimum
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: identity_cycle
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_generated
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: generation_expression
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_updatable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (a.attname)::information_schema.sql_identifier AS column_name,
            (a.attnum)::information_schema.cardinal_number AS ordinal_position,
            (
                CASE
                    WHEN (a.attgenerated = ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid)
                    ELSE NULL::text
                END)::information_schema.character_data AS column_default,
            (
                CASE
                    WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
                    ELSE 'YES'::text
                END)::information_schema.yes_or_no AS is_nullable,
            (
                CASE
                    WHEN (t.typtype = 'd'::"char") THEN
                    CASE
                        WHEN ((bt.typelem <> (0)::oid) AND (bt.typlen = '-1'::integer)) THEN 'ARRAY'::text
                        WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
                        ELSE 'USER-DEFINED'::text
                    END
                    ELSE
                    CASE
                        WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                        WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
                        ELSE 'USER-DEFINED'::text
                    END
                END)::information_schema.character_data AS data_type,
            (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length,
            (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length,
            (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision,
            (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
            (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale,
            (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision,
            (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (
                CASE
                    WHEN (nco.nspname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS collation_catalog,
            (nco.nspname)::information_schema.sql_identifier AS collation_schema,
            (co.collname)::information_schema.sql_identifier AS collation_name,
            (
                CASE
                    WHEN (t.typtype = 'd'::"char") THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS domain_catalog,
            (
                CASE
                    WHEN (t.typtype = 'd'::"char") THEN nt.nspname
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS domain_schema,
            (
                CASE
                    WHEN (t.typtype = 'd'::"char") THEN t.typname
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS domain_name,
            (current_database())::information_schema.sql_identifier AS udt_catalog,
            (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema,
            (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            (a.attnum)::information_schema.sql_identifier AS dtd_identifier,
            ('NO'::character varying)::information_schema.yes_or_no AS is_self_referencing,
            (
                CASE
                    WHEN (a.attidentity = ANY (ARRAY['a'::"char", 'd'::"char"])) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_identity,
            (
                CASE a.attidentity
                    WHEN 'a'::"char" THEN 'ALWAYS'::text
                    WHEN 'd'::"char" THEN 'BY DEFAULT'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS identity_generation,
            (seq.seqstart)::information_schema.character_data AS identity_start,
            (seq.seqincrement)::information_schema.character_data AS identity_increment,
            (seq.seqmax)::information_schema.character_data AS identity_maximum,
            (seq.seqmin)::information_schema.character_data AS identity_minimum,
            (
                CASE
                    WHEN seq.seqcycle THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS identity_cycle,
            (
                CASE
                    WHEN (a.attgenerated <> ''::"char") THEN 'ALWAYS'::text
                    ELSE 'NEVER'::text
                END)::information_schema.character_data AS is_generated,
            (
                CASE
                    WHEN (a.attgenerated <> ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid)
                    ELSE NULL::text
                END)::information_schema.character_data AS generation_expression,
            (
                CASE
                    WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND pg_column_is_updatable((c.oid)::regclass, a.attnum, false))) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_updatable
           FROM ((((((pg_attribute a
             LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
             JOIN (pg_class c
             JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
             JOIN (pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
             LEFT JOIN (pg_type bt
             JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
             LEFT JOIN (pg_collation co
             JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
             LEFT JOIN (pg_depend dep
             JOIN pg_sequence seq ON (((dep.classid = ('pg_class'::regclass)::oid) AND (dep.objid = seq.seqrelid) AND (dep.deptype = 'i'::"char")))) ON (((dep.refclassid = ('pg_class'::regclass)::oid) AND (dep.refobjid = c.oid) AND (dep.refobjsubid = a.attnum))))
          WHERE ((NOT pg_is_other_temp_schema(nc.oid)) AND (a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));
    - type: view
      name: constraint_column_usage
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (x.tblschema)::information_schema.sql_identifier AS table_schema,
            (x.tblname)::information_schema.sql_identifier AS table_name,
            (x.colname)::information_schema.sql_identifier AS column_name,
            (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (x.cstrschema)::information_schema.sql_identifier AS constraint_schema,
            (x.cstrname)::information_schema.sql_identifier AS constraint_name
           FROM ( SELECT DISTINCT nr.nspname,
                    r.relname,
                    r.relowner,
                    a.attname,
                    nc.nspname,
                    c.conname
                   FROM pg_namespace nr,
                    pg_class r,
                    pg_attribute a,
                    pg_depend d,
                    pg_namespace nc,
                    pg_constraint c
                  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
                UNION ALL
                 SELECT nr.nspname,
                    r.relname,
                    r.relowner,
                    a.attname,
                    nc.nspname,
                    c.conname
                   FROM pg_namespace nr,
                    pg_class r,
                    pg_attribute a,
                    pg_namespace nc,
                    pg_constraint c
                  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                        CASE c.contype
                            WHEN 'f'::"char" THEN c.confrelid
                            ELSE c.conrelid
                        END) AND (a.attnum = ANY (
                        CASE c.contype
                            WHEN 'f'::"char" THEN c.confkey
                            ELSE c.conkey
                        END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)
          WHERE pg_has_role(x.tblowner, 'USAGE'::text);
    - type: view
      name: constraint_table_usage
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (nr.nspname)::information_schema.sql_identifier AS table_schema,
            (r.relname)::information_schema.sql_identifier AS table_name,
            (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
            (c.conname)::information_schema.sql_identifier AS constraint_name
           FROM pg_constraint c,
            pg_namespace nc,
            pg_class r,
            pg_namespace nr
          WHERE ((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid) AND (((c.contype = 'f'::"char") AND (c.confrelid = r.oid)) OR ((c.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid))) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE'::text));
    - type: view
      name: data_type_privileges
      columns:
      - name: object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
            x.objschema AS object_schema,
            x.objname AS object_name,
            (x.objtype)::information_schema.character_data AS object_type,
            x.objdtdid AS dtd_identifier
           FROM ( SELECT attributes.udt_schema,
                    attributes.udt_name,
                    'USER-DEFINED TYPE'::text AS text,
                    attributes.dtd_identifier
                   FROM information_schema.attributes
                UNION ALL
                 SELECT columns.table_schema,
                    columns.table_name,
                    'TABLE'::text AS text,
                    columns.dtd_identifier
                   FROM information_schema.columns
                UNION ALL
                 SELECT domains.domain_schema,
                    domains.domain_name,
                    'DOMAIN'::text AS text,
                    domains.dtd_identifier
                   FROM information_schema.domains
                UNION ALL
                 SELECT parameters.specific_schema,
                    parameters.specific_name,
                    'ROUTINE'::text AS text,
                    parameters.dtd_identifier
                   FROM information_schema.parameters
                UNION ALL
                 SELECT routines.specific_schema,
                    routines.specific_name,
                    'ROUTINE'::text AS text,
                    routines.dtd_identifier
                   FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);
    - type: view
      name: domain_constraints
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_deferrable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: initially_deferred
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (rs.nspname)::information_schema.sql_identifier AS constraint_schema,
            (con.conname)::information_schema.sql_identifier AS constraint_name,
            (current_database())::information_schema.sql_identifier AS domain_catalog,
            (n.nspname)::information_schema.sql_identifier AS domain_schema,
            (t.typname)::information_schema.sql_identifier AS domain_name,
            (
                CASE
                    WHEN con.condeferrable THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_deferrable,
            (
                CASE
                    WHEN con.condeferred THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS initially_deferred
           FROM pg_namespace rs,
            pg_namespace n,
            pg_constraint con,
            pg_type t
          WHERE ((rs.oid = con.connamespace) AND (n.oid = t.typnamespace) AND (t.oid = con.contypid) AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)));
    - type: view
      name: domain_udt_usage
      columns:
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
            (bt.typname)::information_schema.sql_identifier AS udt_name,
            (current_database())::information_schema.sql_identifier AS domain_catalog,
            (nt.nspname)::information_schema.sql_identifier AS domain_schema,
            (t.typname)::information_schema.sql_identifier AS domain_name
           FROM pg_type t,
            pg_namespace nt,
            pg_type bt,
            pg_namespace nbt
          WHERE ((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid) AND (bt.typnamespace = nbt.oid) AND (t.typtype = 'd'::"char") AND pg_has_role(bt.typowner, 'USAGE'::text));
    - type: view
      name: domains
      columns:
      - name: domain_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: domain_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: domain_default
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS domain_catalog,
            (nt.nspname)::information_schema.sql_identifier AS domain_schema,
            (t.typname)::information_schema.sql_identifier AS domain_name,
            (
                CASE
                    WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                    WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
                    ELSE 'USER-DEFINED'::text
                END)::information_schema.character_data AS data_type,
            (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_maximum_length,
            (information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (
                CASE
                    WHEN (nco.nspname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS collation_catalog,
            (nco.nspname)::information_schema.sql_identifier AS collation_schema,
            (co.collname)::information_schema.sql_identifier AS collation_name,
            (information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision,
            (information_schema._pg_numeric_precision_radix(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision_radix,
            (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_scale,
            (information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS datetime_precision,
            (information_schema._pg_interval_type(t.typbasetype, t.typtypmod))::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (t.typdefault)::information_schema.character_data AS domain_default,
            (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
            (bt.typname)::information_schema.sql_identifier AS udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            (1)::information_schema.sql_identifier AS dtd_identifier
           FROM (((pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             JOIN (pg_type bt
             JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typbasetype = bt.oid) AND (t.typtype = 'd'::"char"))))
             LEFT JOIN (pg_collation co
             JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((t.typcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
          WHERE (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));
    - type: view
      name: element_types
      columns:
      - name: object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: collection_type_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: domain_default
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
            (n.nspname)::information_schema.sql_identifier AS object_schema,
            x.objname AS object_name,
            (x.objtype)::information_schema.character_data AS object_type,
            (x.objdtdid)::information_schema.sql_identifier AS collection_type_identifier,
            (
                CASE
                    WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(bt.oid, NULL::integer)
                    ELSE 'USER-DEFINED'::text
                END)::information_schema.character_data AS data_type,
            (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
            (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (
                CASE
                    WHEN (nco.nspname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS collation_catalog,
            (nco.nspname)::information_schema.sql_identifier AS collation_schema,
            (co.collname)::information_schema.sql_identifier AS collation_name,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
            (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
            (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
            (NULL::character varying)::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (NULL::character varying)::information_schema.character_data AS domain_default,
            (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
            (bt.typname)::information_schema.sql_identifier AS udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            (('a'::text || (x.objdtdid)::text))::information_schema.sql_identifier AS dtd_identifier
           FROM pg_namespace n,
            pg_type at,
            pg_namespace nbt,
            pg_type bt,
            (( SELECT c.relnamespace,
                    (c.relname)::information_schema.sql_identifier AS relname,
                        CASE
                            WHEN (c.relkind = 'c'::"char") THEN 'USER-DEFINED TYPE'::text
                            ELSE 'TABLE'::text
                        END AS "case",
                    a.attnum,
                    a.atttypid,
                    a.attcollation
                   FROM pg_class c,
                    pg_attribute a
                  WHERE ((c.oid = a.attrelid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"])) AND (a.attnum > 0) AND (NOT a.attisdropped))
                UNION ALL
                 SELECT t.typnamespace,
                    (t.typname)::information_schema.sql_identifier AS typname,
                    'DOMAIN'::text AS text,
                    1,
                    t.typbasetype,
                    t.typcollation
                   FROM pg_type t
                  WHERE (t.typtype = 'd'::"char")
                UNION ALL
                 SELECT ss.pronamespace,
                    (nameconcatoid(ss.proname, ss.oid))::information_schema.sql_identifier AS nameconcatoid,
                    'ROUTINE'::text AS text,
                    (ss.x).n AS n,
                    (ss.x).x AS x,
                    0
                   FROM ( SELECT p.pronamespace,
                            p.proname,
                            p.oid,
                            information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
                           FROM pg_proc p) ss
                UNION ALL
                 SELECT p.pronamespace,
                    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS nameconcatoid,
                    'ROUTINE'::text AS text,
                    0,
                    p.prorettype,
                    0
                   FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
             LEFT JOIN (pg_collation co
             JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
          WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND ((at.typelem <> (0)::oid) AND (at.typlen = '-1'::integer)) AND (at.typelem = bt.oid) AND (nbt.oid = bt.typnamespace) AND ((n.nspname, (x.objname)::name, x.objtype, ((x.objdtdid)::information_schema.sql_identifier)::name) IN ( SELECT data_type_privileges.object_schema,
                    data_type_privileges.object_name,
                    data_type_privileges.object_type,
                    data_type_privileges.dtd_identifier
                   FROM information_schema.data_type_privileges)));
    - type: view
      name: enabled_roles
      columns:
      - name: role_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (a.rolname)::information_schema.sql_identifier AS role_name
           FROM pg_authid a
          WHERE pg_has_role(a.oid, 'USAGE'::text);
    - type: view
      name: foreign_data_wrapper_options
      columns:
      - name: foreign_data_wrapper_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_value
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT w.foreign_data_wrapper_catalog,
            w.foreign_data_wrapper_name,
            ((pg_options_to_table(w.fdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
            ((pg_options_to_table(w.fdwoptions)).option_value)::information_schema.character_data AS option_value
           FROM information_schema._pg_foreign_data_wrappers w;
    - type: view
      name: foreign_data_wrappers
      columns:
      - name: foreign_data_wrapper_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: library_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: foreign_data_wrapper_language
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT w.foreign_data_wrapper_catalog,
            w.foreign_data_wrapper_name,
            w.authorization_identifier,
            (NULL::character varying)::information_schema.character_data AS library_name,
            w.foreign_data_wrapper_language
           FROM information_schema._pg_foreign_data_wrappers w;
    - type: view
      name: foreign_server_options
      columns:
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_value
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT s.foreign_server_catalog,
            s.foreign_server_name,
            ((pg_options_to_table(s.srvoptions)).option_name)::information_schema.sql_identifier AS option_name,
            ((pg_options_to_table(s.srvoptions)).option_value)::information_schema.character_data AS option_value
           FROM information_schema._pg_foreign_servers s;
    - type: view
      name: foreign_servers
      columns:
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_data_wrapper_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: foreign_server_version
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT _pg_foreign_servers.foreign_server_catalog,
            _pg_foreign_servers.foreign_server_name,
            _pg_foreign_servers.foreign_data_wrapper_catalog,
            _pg_foreign_servers.foreign_data_wrapper_name,
            _pg_foreign_servers.foreign_server_type,
            _pg_foreign_servers.foreign_server_version,
            _pg_foreign_servers.authorization_identifier
           FROM information_schema._pg_foreign_servers;
    - type: view
      name: foreign_table_options
      columns:
      - name: foreign_table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_value
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT t.foreign_table_catalog,
            t.foreign_table_schema,
            t.foreign_table_name,
            ((pg_options_to_table(t.ftoptions)).option_name)::information_schema.sql_identifier AS option_name,
            ((pg_options_to_table(t.ftoptions)).option_value)::information_schema.character_data AS option_value
           FROM information_schema._pg_foreign_tables t;
    - type: view
      name: foreign_tables
      columns:
      - name: foreign_table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT _pg_foreign_tables.foreign_table_catalog,
            _pg_foreign_tables.foreign_table_schema,
            _pg_foreign_tables.foreign_table_name,
            _pg_foreign_tables.foreign_server_catalog,
            _pg_foreign_tables.foreign_server_name
           FROM information_schema._pg_foreign_tables;
    - type: view
      name: information_schema_catalog_name
      columns:
      - name: catalog_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |
        SELECT (current_database())::information_schema.sql_identifier AS catalog_name;
    - type: view
      name: key_column_usage
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordinal_position
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: position_in_unique_constraint
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (ss.nc_nspname)::information_schema.sql_identifier AS constraint_schema,
            (ss.conname)::information_schema.sql_identifier AS constraint_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (ss.nr_nspname)::information_schema.sql_identifier AS table_schema,
            (ss.relname)::information_schema.sql_identifier AS table_name,
            (a.attname)::information_schema.sql_identifier AS column_name,
            ((ss.x).n)::information_schema.cardinal_number AS ordinal_position,
            (
                CASE
                    WHEN (ss.contype = 'f'::"char") THEN information_schema._pg_index_position(ss.conindid, ss.confkey[(ss.x).n])
                    ELSE NULL::integer
                END)::information_schema.cardinal_number AS position_in_unique_constraint
           FROM pg_attribute a,
            ( SELECT r.oid AS roid,
                    r.relname,
                    r.relowner,
                    nc.nspname AS nc_nspname,
                    nr.nspname AS nr_nspname,
                    c.oid AS coid,
                    c.conname,
                    c.contype,
                    c.conindid,
                    c.confkey,
                    c.confrelid,
                    information_schema._pg_expandarray(c.conkey) AS x
                   FROM pg_namespace nr,
                    pg_class r,
                    pg_namespace nc,
                    pg_constraint c
                  WHERE ((nr.oid = r.relnamespace) AND (r.oid = c.conrelid) AND (nc.oid = c.connamespace) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)))) ss
          WHERE ((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x) AND (NOT a.attisdropped) AND (pg_has_role(ss.relowner, 'USAGE'::text) OR has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));
    - type: view
      name: parameters
      columns:
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordinal_position
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: parameter_mode
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_result
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: as_locator
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: parameter_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: parameter_default
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS specific_catalog,
            (ss.n_nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(ss.proname, ss.p_oid))::information_schema.sql_identifier AS specific_name,
            ((ss.x).n)::information_schema.cardinal_number AS ordinal_position,
            (
                CASE
                    WHEN (ss.proargmodes IS NULL) THEN 'IN'::text
                    WHEN (ss.proargmodes[(ss.x).n] = 'i'::"char") THEN 'IN'::text
                    WHEN (ss.proargmodes[(ss.x).n] = 'o'::"char") THEN 'OUT'::text
                    WHEN (ss.proargmodes[(ss.x).n] = 'b'::"char") THEN 'INOUT'::text
                    WHEN (ss.proargmodes[(ss.x).n] = 'v'::"char") THEN 'IN'::text
                    WHEN (ss.proargmodes[(ss.x).n] = 't'::"char") THEN 'OUT'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS parameter_mode,
            ('NO'::character varying)::information_schema.yes_or_no AS is_result,
            ('NO'::character varying)::information_schema.yes_or_no AS as_locator,
            (NULLIF(ss.proargnames[(ss.x).n], ''::text))::information_schema.sql_identifier AS parameter_name,
            (
                CASE
                    WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                    WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
                    ELSE 'USER-DEFINED'::text
                END)::information_schema.character_data AS data_type,
            (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
            (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (NULL::name)::information_schema.sql_identifier AS collation_catalog,
            (NULL::name)::information_schema.sql_identifier AS collation_schema,
            (NULL::name)::information_schema.sql_identifier AS collation_name,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
            (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
            (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
            (NULL::character varying)::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nt.nspname)::information_schema.sql_identifier AS udt_schema,
            (t.typname)::information_schema.sql_identifier AS udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            ((ss.x).n)::information_schema.sql_identifier AS dtd_identifier,
            (
                CASE
                    WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
                    ELSE NULL::text
                END)::information_schema.character_data AS parameter_default
           FROM pg_type t,
            pg_namespace nt,
            ( SELECT n.nspname AS n_nspname,
                    p.proname,
                    p.oid AS p_oid,
                    p.proowner,
                    p.proargnames,
                    p.proargmodes,
                    information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
                   FROM pg_namespace n,
                    pg_proc p
                  WHERE ((n.oid = p.pronamespace) AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)))) ss
          WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid));
    - type: view
      name: referential_constraints
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: unique_constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: unique_constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: unique_constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: match_option
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: update_rule
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: delete_rule
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (ncon.nspname)::information_schema.sql_identifier AS constraint_schema,
            (con.conname)::information_schema.sql_identifier AS constraint_name,
            (
                CASE
                    WHEN (npkc.nspname IS NULL) THEN NULL::name
                    ELSE current_database()
                END)::information_schema.sql_identifier AS unique_constraint_catalog,
            (npkc.nspname)::information_schema.sql_identifier AS unique_constraint_schema,
            (pkc.conname)::information_schema.sql_identifier AS unique_constraint_name,
            (
                CASE con.confmatchtype
                    WHEN 'f'::"char" THEN 'FULL'::text
                    WHEN 'p'::"char" THEN 'PARTIAL'::text
                    WHEN 's'::"char" THEN 'NONE'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS match_option,
            (
                CASE con.confupdtype
                    WHEN 'c'::"char" THEN 'CASCADE'::text
                    WHEN 'n'::"char" THEN 'SET NULL'::text
                    WHEN 'd'::"char" THEN 'SET DEFAULT'::text
                    WHEN 'r'::"char" THEN 'RESTRICT'::text
                    WHEN 'a'::"char" THEN 'NO ACTION'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS update_rule,
            (
                CASE con.confdeltype
                    WHEN 'c'::"char" THEN 'CASCADE'::text
                    WHEN 'n'::"char" THEN 'SET NULL'::text
                    WHEN 'd'::"char" THEN 'SET DEFAULT'::text
                    WHEN 'r'::"char" THEN 'RESTRICT'::text
                    WHEN 'a'::"char" THEN 'NO ACTION'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS delete_rule
           FROM ((((((pg_namespace ncon
             JOIN pg_constraint con ON ((ncon.oid = con.connamespace)))
             JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f'::"char"))))
             LEFT JOIN pg_depend d1 ON (((d1.objid = con.oid) AND (d1.classid = ('pg_constraint'::regclass)::oid) AND (d1.refclassid = ('pg_class'::regclass)::oid) AND (d1.refobjsubid = 0))))
             LEFT JOIN pg_depend d2 ON (((d2.refclassid = ('pg_constraint'::regclass)::oid) AND (d2.classid = ('pg_class'::regclass)::oid) AND (d2.objid = d1.refobjid) AND (d2.objsubid = 0) AND (d2.deptype = 'i'::"char"))))
             LEFT JOIN pg_constraint pkc ON (((pkc.oid = d2.refobjid) AND (pkc.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (pkc.conrelid = con.confrelid))))
             LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid)))
          WHERE (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));
    - type: view
      name: role_column_grants
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT column_privileges.grantor,
            column_privileges.grantee,
            column_privileges.table_catalog,
            column_privileges.table_schema,
            column_privileges.table_name,
            column_privileges.column_name,
            column_privileges.privilege_type,
            column_privileges.is_grantable
           FROM information_schema.column_privileges
          WHERE (((column_privileges.grantor)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)) OR ((column_privileges.grantee)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)));
    - type: view
      name: role_routine_grants
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT routine_privileges.grantor,
            routine_privileges.grantee,
            routine_privileges.specific_catalog,
            routine_privileges.specific_schema,
            routine_privileges.specific_name,
            routine_privileges.routine_catalog,
            routine_privileges.routine_schema,
            routine_privileges.routine_name,
            routine_privileges.privilege_type,
            routine_privileges.is_grantable
           FROM information_schema.routine_privileges
          WHERE (((routine_privileges.grantor)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)) OR ((routine_privileges.grantee)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)));
    - type: view
      name: role_table_grants
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: with_hierarchy
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT table_privileges.grantor,
            table_privileges.grantee,
            table_privileges.table_catalog,
            table_privileges.table_schema,
            table_privileges.table_name,
            table_privileges.privilege_type,
            table_privileges.is_grantable,
            table_privileges.with_hierarchy
           FROM information_schema.table_privileges
          WHERE (((table_privileges.grantor)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)) OR ((table_privileges.grantee)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)));
    - type: view
      name: role_udt_grants
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT udt_privileges.grantor,
            udt_privileges.grantee,
            udt_privileges.udt_catalog,
            udt_privileges.udt_schema,
            udt_privileges.udt_name,
            udt_privileges.privilege_type,
            udt_privileges.is_grantable
           FROM information_schema.udt_privileges
          WHERE (((udt_privileges.grantor)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)) OR ((udt_privileges.grantee)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)));
    - type: view
      name: role_usage_grants
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT usage_privileges.grantor,
            usage_privileges.grantee,
            usage_privileges.object_catalog,
            usage_privileges.object_schema,
            usage_privileges.object_name,
            usage_privileges.object_type,
            usage_privileges.privilege_type,
            usage_privileges.is_grantable
           FROM information_schema.usage_privileges
          WHERE (((usage_privileges.grantor)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)) OR ((usage_privileges.grantee)::name IN ( SELECT enabled_roles.role_name
                   FROM information_schema.enabled_roles)));
    - type: view
      name: routine_privileges
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS specific_catalog,
            (n.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
            (current_database())::information_schema.sql_identifier AS routine_catalog,
            (n.nspname)::information_schema.sql_identifier AS routine_schema,
            (p.proname)::information_schema.sql_identifier AS routine_name,
            ('EXECUTE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_proc.oid,
                    pg_proc.proname,
                    pg_proc.proowner,
                    pg_proc.pronamespace,
                    (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).is_grantable AS is_grantable
                   FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
            pg_namespace n,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((p.pronamespace = n.oid) AND (grantee.oid = p.grantee) AND (u_grantor.oid = p.grantor) AND (p.prtype = 'EXECUTE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)));
    - type: view
      name: routines
      columns:
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: module_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: module_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: module_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: type_udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: type_udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: type_udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: routine_body
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: routine_definition
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: external_name
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: external_language
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: parameter_style
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_deterministic
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: sql_data_access
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_null_call
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: sql_path
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: schema_level_routine
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: max_dynamic_result_sets
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: is_user_defined_cast
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_implicitly_invocable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: security_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: to_sql_specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: to_sql_specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: to_sql_specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: as_locator
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: created
        datatype:
          type: information_schema.time_stamp
          nullable: true
      - name: last_altered
        datatype:
          type: information_schema.time_stamp
          nullable: true
      - name: new_savepoint_level
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_udt_dependent
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: result_cast_from_data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: result_cast_as_locator
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: result_cast_char_max_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_char_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_char_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_char_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_char_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: result_cast_interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_type_udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_type_udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_type_udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_scope_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_scope_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_scope_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: result_cast_maximum_cardinality
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: result_cast_dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS specific_catalog,
            (n.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
            (current_database())::information_schema.sql_identifier AS routine_catalog,
            (n.nspname)::information_schema.sql_identifier AS routine_schema,
            (p.proname)::information_schema.sql_identifier AS routine_name,
            (
                CASE p.prokind
                    WHEN 'f'::"char" THEN 'FUNCTION'::text
                    WHEN 'p'::"char" THEN 'PROCEDURE'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS routine_type,
            (NULL::name)::information_schema.sql_identifier AS module_catalog,
            (NULL::name)::information_schema.sql_identifier AS module_schema,
            (NULL::name)::information_schema.sql_identifier AS module_name,
            (NULL::name)::information_schema.sql_identifier AS udt_catalog,
            (NULL::name)::information_schema.sql_identifier AS udt_schema,
            (NULL::name)::information_schema.sql_identifier AS udt_name,
            (
                CASE
                    WHEN (p.prokind = 'p'::"char") THEN NULL::text
                    WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                    WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
                    ELSE 'USER-DEFINED'::text
                END)::information_schema.character_data AS data_type,
            (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
            (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (NULL::name)::information_schema.sql_identifier AS collation_catalog,
            (NULL::name)::information_schema.sql_identifier AS collation_schema,
            (NULL::name)::information_schema.sql_identifier AS collation_name,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
            (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
            (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
            (NULL::character varying)::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (
                CASE
                    WHEN (nt.nspname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS type_udt_catalog,
            (nt.nspname)::information_schema.sql_identifier AS type_udt_schema,
            (t.typname)::information_schema.sql_identifier AS type_udt_name,
            (NULL::name)::information_schema.sql_identifier AS scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS scope_schema,
            (NULL::name)::information_schema.sql_identifier AS scope_name,
            (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
            (
                CASE
                    WHEN (p.prokind <> 'p'::"char") THEN 0
                    ELSE NULL::integer
                END)::information_schema.sql_identifier AS dtd_identifier,
            (
                CASE
                    WHEN (l.lanname = 'sql'::name) THEN 'SQL'::text
                    ELSE 'EXTERNAL'::text
                END)::information_schema.character_data AS routine_body,
            (
                CASE
                    WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc
                    ELSE NULL::text
                END)::information_schema.character_data AS routine_definition,
            (
                CASE
                    WHEN (l.lanname = 'c'::name) THEN p.prosrc
                    ELSE NULL::text
                END)::information_schema.character_data AS external_name,
            (upper((l.lanname)::text))::information_schema.character_data AS external_language,
            ('GENERAL'::character varying)::information_schema.character_data AS parameter_style,
            (
                CASE
                    WHEN (p.provolatile = 'i'::"char") THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_deterministic,
            ('MODIFIES'::character varying)::information_schema.character_data AS sql_data_access,
            (
                CASE
                    WHEN (p.prokind <> 'p'::"char") THEN
                    CASE
                        WHEN p.proisstrict THEN 'YES'::text
                        ELSE 'NO'::text
                    END
                    ELSE NULL::text
                END)::information_schema.yes_or_no AS is_null_call,
            (NULL::character varying)::information_schema.character_data AS sql_path,
            ('YES'::character varying)::information_schema.yes_or_no AS schema_level_routine,
            (0)::information_schema.cardinal_number AS max_dynamic_result_sets,
            (NULL::character varying)::information_schema.yes_or_no AS is_user_defined_cast,
            (NULL::character varying)::information_schema.yes_or_no AS is_implicitly_invocable,
            (
                CASE
                    WHEN p.prosecdef THEN 'DEFINER'::text
                    ELSE 'INVOKER'::text
                END)::information_schema.character_data AS security_type,
            (NULL::name)::information_schema.sql_identifier AS to_sql_specific_catalog,
            (NULL::name)::information_schema.sql_identifier AS to_sql_specific_schema,
            (NULL::name)::information_schema.sql_identifier AS to_sql_specific_name,
            ('NO'::character varying)::information_schema.yes_or_no AS as_locator,
            (NULL::timestamp with time zone)::information_schema.time_stamp AS created,
            (NULL::timestamp with time zone)::information_schema.time_stamp AS last_altered,
            (NULL::character varying)::information_schema.yes_or_no AS new_savepoint_level,
            ('NO'::character varying)::information_schema.yes_or_no AS is_udt_dependent,
            (NULL::character varying)::information_schema.character_data AS result_cast_from_data_type,
            (NULL::character varying)::information_schema.yes_or_no AS result_cast_as_locator,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_char_max_length,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_char_octet_length,
            (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_schema,
            (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_name,
            (NULL::name)::information_schema.sql_identifier AS result_cast_collation_catalog,
            (NULL::name)::information_schema.sql_identifier AS result_cast_collation_schema,
            (NULL::name)::information_schema.sql_identifier AS result_cast_collation_name,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision_radix,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_scale,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_datetime_precision,
            (NULL::character varying)::information_schema.character_data AS result_cast_interval_type,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_interval_precision,
            (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_catalog,
            (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_schema,
            (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_name,
            (NULL::name)::information_schema.sql_identifier AS result_cast_scope_catalog,
            (NULL::name)::information_schema.sql_identifier AS result_cast_scope_schema,
            (NULL::name)::information_schema.sql_identifier AS result_cast_scope_name,
            (NULL::integer)::information_schema.cardinal_number AS result_cast_maximum_cardinality,
            (NULL::name)::information_schema.sql_identifier AS result_cast_dtd_identifier
           FROM (((pg_namespace n
             JOIN pg_proc p ON ((n.oid = p.pronamespace)))
             JOIN pg_language l ON ((p.prolang = l.oid)))
             LEFT JOIN (pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON (((p.prorettype = t.oid) AND (p.prokind <> 'p'::"char"))))
          WHERE (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text));
    - type: view
      name: schemata
      columns:
      - name: catalog_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: schema_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: schema_owner
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: default_character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: sql_path
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS catalog_name,
            (n.nspname)::information_schema.sql_identifier AS schema_name,
            (u.rolname)::information_schema.sql_identifier AS schema_owner,
            (NULL::name)::information_schema.sql_identifier AS default_character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS default_character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS default_character_set_name,
            (NULL::character varying)::information_schema.character_data AS sql_path
           FROM pg_namespace n,
            pg_authid u
          WHERE ((n.nspowner = u.oid) AND (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text)));
    - type: view
      name: sequences
      columns:
      - name: sequence_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: sequence_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: sequence_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: start_value
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: minimum_value
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: maximum_value
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: increment
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: cycle_option
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS sequence_catalog,
            (nc.nspname)::information_schema.sql_identifier AS sequence_schema,
            (c.relname)::information_schema.sql_identifier AS sequence_name,
            (format_type(s.seqtypid, NULL::integer))::information_schema.character_data AS data_type,
            (information_schema._pg_numeric_precision(s.seqtypid, '-1'::integer))::information_schema.cardinal_number AS numeric_precision,
            (2)::information_schema.cardinal_number AS numeric_precision_radix,
            (0)::information_schema.cardinal_number AS numeric_scale,
            (s.seqstart)::information_schema.character_data AS start_value,
            (s.seqmin)::information_schema.character_data AS minimum_value,
            (s.seqmax)::information_schema.character_data AS maximum_value,
            (s.seqincrement)::information_schema.character_data AS increment,
            (
                CASE
                    WHEN s.seqcycle THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS cycle_option
           FROM pg_namespace nc,
            pg_class c,
            pg_sequence s
          WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT (EXISTS ( SELECT 1
                   FROM pg_depend
                  WHERE ((pg_depend.classid = ('pg_class'::regclass)::oid) AND (pg_depend.objid = c.oid) AND (pg_depend.deptype = 'i'::"char"))))) AND (NOT pg_is_other_temp_schema(nc.oid)) AND (c.oid = s.seqrelid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text)));
    - type: view
      name: table_constraints
      columns:
      - name: constraint_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: constraint_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_deferrable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: initially_deferred
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: enforced
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
            (c.conname)::information_schema.sql_identifier AS constraint_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nr.nspname)::information_schema.sql_identifier AS table_schema,
            (r.relname)::information_schema.sql_identifier AS table_name,
            (
                CASE c.contype
                    WHEN 'c'::"char" THEN 'CHECK'::text
                    WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
                    WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
                    WHEN 'u'::"char" THEN 'UNIQUE'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS constraint_type,
            (
                CASE
                    WHEN c.condeferrable THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_deferrable,
            (
                CASE
                    WHEN c.condeferred THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS initially_deferred,
            ('YES'::character varying)::information_schema.yes_or_no AS enforced
           FROM pg_namespace nc,
            pg_namespace nr,
            pg_constraint c,
            pg_class r
          WHERE ((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace) AND (c.conrelid = r.oid) AND (c.contype <> ALL (ARRAY['t'::"char", 'x'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)))
        UNION ALL
         SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
            (nr.nspname)::information_schema.sql_identifier AS constraint_schema,
            (((((((nr.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nr.nspname)::information_schema.sql_identifier AS table_schema,
            (r.relname)::information_schema.sql_identifier AS table_name,
            ('CHECK'::character varying)::information_schema.character_data AS constraint_type,
            ('NO'::character varying)::information_schema.yes_or_no AS is_deferrable,
            ('NO'::character varying)::information_schema.yes_or_no AS initially_deferred,
            ('YES'::character varying)::information_schema.yes_or_no AS enforced
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND a.attnotnull AND (a.attnum > 0) AND (NOT a.attisdropped) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)));
    - type: view
      name: table_privileges
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: with_hierarchy
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (c.prtype)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable,
            (
                CASE
                    WHEN (c.prtype = 'SELECT'::text) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS with_hierarchy
           FROM ( SELECT pg_class.oid,
                    pg_class.relname,
                    pg_class.relnamespace,
                    pg_class.relkind,
                    pg_class.relowner,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
                   FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
            pg_namespace nc,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)));
    - type: view
      name: tables
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: self_referencing_column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: reference_generation
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: user_defined_type_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: user_defined_type_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: user_defined_type_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: is_insertable_into
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_typed
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: commit_action
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (
                CASE
                    WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text
                    WHEN (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'BASE TABLE'::text
                    WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
                    WHEN (c.relkind = 'f'::"char") THEN 'FOREIGN'::text
                    ELSE NULL::text
                END)::information_schema.character_data AS table_type,
            (NULL::name)::information_schema.sql_identifier AS self_referencing_column_name,
            (NULL::character varying)::information_schema.character_data AS reference_generation,
            (
                CASE
                    WHEN (t.typname IS NOT NULL) THEN current_database()
                    ELSE NULL::name
                END)::information_schema.sql_identifier AS user_defined_type_catalog,
            (nt.nspname)::information_schema.sql_identifier AS user_defined_type_schema,
            (t.typname)::information_schema.sql_identifier AS user_defined_type_name,
            (
                CASE
                    WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8))) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_insertable_into,
            (
                CASE
                    WHEN (t.typname IS NOT NULL) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_typed,
            (NULL::character varying)::information_schema.character_data AS commit_action
           FROM ((pg_namespace nc
             JOIN pg_class c ON ((nc.oid = c.relnamespace)))
             LEFT JOIN (pg_type t
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid)))
          WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));
    - type: view
      name: transforms
      columns:
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: group_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: transform_type
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nt.nspname)::information_schema.sql_identifier AS udt_schema,
            (t.typname)::information_schema.sql_identifier AS udt_name,
            (current_database())::information_schema.sql_identifier AS specific_catalog,
            (np.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
            (l.lanname)::information_schema.sql_identifier AS group_name,
            ('FROM SQL'::character varying)::information_schema.character_data AS transform_type
           FROM (((((pg_type t
             JOIN pg_transform x ON ((t.oid = x.trftype)))
             JOIN pg_language l ON ((x.trflang = l.oid)))
             JOIN pg_proc p ON (((x.trffromsql)::oid = p.oid)))
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
        UNION
         SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
            (nt.nspname)::information_schema.sql_identifier AS udt_schema,
            (t.typname)::information_schema.sql_identifier AS udt_name,
            (current_database())::information_schema.sql_identifier AS specific_catalog,
            (np.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
            (l.lanname)::information_schema.sql_identifier AS group_name,
            ('TO SQL'::character varying)::information_schema.character_data AS transform_type
           FROM (((((pg_type t
             JOIN pg_transform x ON ((t.oid = x.trftype)))
             JOIN pg_language l ON ((x.trflang = l.oid)))
             JOIN pg_proc p ON (((x.trftosql)::oid = p.oid)))
             JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
          ORDER BY 1, 2, 3, 7, 8;
    - type: view
      name: triggered_update_columns
      columns:
      - name: trigger_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: trigger_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: trigger_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_table
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_column
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog,
            (n.nspname)::information_schema.sql_identifier AS trigger_schema,
            (t.tgname)::information_schema.sql_identifier AS trigger_name,
            (current_database())::information_schema.sql_identifier AS event_object_catalog,
            (n.nspname)::information_schema.sql_identifier AS event_object_schema,
            (c.relname)::information_schema.sql_identifier AS event_object_table,
            (a.attname)::information_schema.sql_identifier AS event_object_column
           FROM pg_namespace n,
            pg_class c,
            pg_trigger t,
            ( SELECT ta0.tgoid,
                    (ta0.tgat).x AS tgattnum,
                    (ta0.tgat).n AS tgattpos
                   FROM ( SELECT pg_trigger.oid AS tgoid,
                            information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
                           FROM pg_trigger) ta0) ta,
            pg_attribute a
          WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (t.oid = ta.tgoid) AND ((a.attrelid = t.tgrelid) AND (a.attnum = ta.tgattnum)) AND (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'INSERT, UPDATE, REFERENCES'::text)));
    - type: view
      name: triggers
      columns:
      - name: trigger_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: trigger_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: trigger_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_manipulation
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: event_object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: event_object_table
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: action_order
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: action_condition
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: action_statement
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: action_orientation
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: action_timing
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: action_reference_old_table
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: action_reference_new_table
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: action_reference_old_row
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: action_reference_new_row
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: created
        datatype:
          type: information_schema.time_stamp
          nullable: true
      manual: true
      definition: "SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog,\n    (n.nspname)::information_schema.sql_identifier AS trigger_schema,\n    (t.tgname)::information_schema.sql_identifier AS trigger_name,\n    (em.text)::information_schema.character_data AS event_manipulation,\n    (current_database())::information_schema.sql_identifier AS event_object_catalog,\n    (n.nspname)::information_schema.sql_identifier AS event_object_schema,\n    (c.relname)::information_schema.sql_identifier AS event_object_table,\n    (rank() OVER (PARTITION BY (n.nspname)::information_schema.sql_identifier, (c.relname)::information_schema.sql_identifier, em.num, ((t.tgtype)::integer & 1), ((t.tgtype)::integer & 66) ORDER BY t.tgname))::information_schema.cardinal_number AS action_order,\n    (\n        CASE\n            WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(t.oid), '.{35,} WHEN \\((.+)\\) EXECUTE FUNCTION'::text))[1]\n            ELSE NULL::text\n        END)::information_schema.character_data AS action_condition,\n    (\"substring\"(pg_get_triggerdef(t.oid), (\"position\"(\"substring\"(pg_get_triggerdef(t.oid), 48), 'EXECUTE FUNCTION'::text) + 47)))::information_schema.character_data AS action_statement,\n    (\n        CASE ((t.tgtype)::integer & 1)\n            WHEN 1 THEN 'ROW'::text\n            ELSE 'STATEMENT'::text\n        END)::information_schema.character_data AS action_orientation,\n    (\n        CASE ((t.tgtype)::integer & 66)\n            WHEN 2 THEN 'BEFORE'::text\n            WHEN 64 THEN 'INSTEAD OF'::text\n            ELSE 'AFTER'::text\n        END)::information_schema.character_data AS action_timing,\n    (t.tgoldtable)::information_schema.sql_identifier AS action_reference_old_table,\n    (t.tgnewtable)::information_schema.sql_identifier AS action_reference_new_table,\n    (NULL::name)::information_schema.sql_identifier AS action_reference_old_row,\n    (NULL::name)::information_schema.sql_identifier AS action_reference_new_row,\n    (NULL::timestamp with time zone)::information_schema.time_stamp AS created\n   FROM pg_namespace n,\n    pg_class c,\n    pg_trigger t,\n    ( VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)\n  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (((t.tgtype)::integer & em.num) <> 0) AND (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)));"
    - type: view
      name: udt_privileges
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: udt_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS udt_catalog,
            (n.nspname)::information_schema.sql_identifier AS udt_schema,
            (t.typname)::information_schema.sql_identifier AS udt_name,
            ('TYPE USAGE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_type.oid,
                    pg_type.typname,
                    pg_type.typnamespace,
                    pg_type.typtype,
                    pg_type.typowner,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).is_grantable AS is_grantable
                   FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
            pg_namespace n,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'c'::"char") AND (t.grantee = grantee.oid) AND (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)));
    - type: view
      name: usage_privileges
      columns:
      - name: grantor
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: grantee
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: object_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: privilege_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_grantable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (u.rolname)::information_schema.sql_identifier AS grantor,
            ('PUBLIC'::name)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS object_catalog,
            (n.nspname)::information_schema.sql_identifier AS object_schema,
            (c.collname)::information_schema.sql_identifier AS object_name,
            ('COLLATION'::character varying)::information_schema.character_data AS object_type,
            ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
            ('NO'::character varying)::information_schema.yes_or_no AS is_grantable
           FROM pg_authid u,
            pg_namespace n,
            pg_collation c
          WHERE ((u.oid = c.collowner) AND (c.collnamespace = n.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
                   FROM pg_database
                  WHERE (pg_database.datname = current_database()))])))
        UNION ALL
         SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS object_catalog,
            (n.nspname)::information_schema.sql_identifier AS object_schema,
            (t.typname)::information_schema.sql_identifier AS object_name,
            ('DOMAIN'::character varying)::information_schema.character_data AS object_type,
            ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_type.oid,
                    pg_type.typname,
                    pg_type.typnamespace,
                    pg_type.typtype,
                    pg_type.typowner,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).is_grantable AS is_grantable
                   FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
            pg_namespace n,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'd'::"char") AND (t.grantee = grantee.oid) AND (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
        UNION ALL
         SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS object_catalog,
            (''::name)::information_schema.sql_identifier AS object_schema,
            (fdw.fdwname)::information_schema.sql_identifier AS object_name,
            ('FOREIGN DATA WRAPPER'::character varying)::information_schema.character_data AS object_type,
            ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_foreign_data_wrapper.fdwname,
                    pg_foreign_data_wrapper.fdwowner,
                    (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).is_grantable AS is_grantable
                   FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((u_grantor.oid = fdw.grantor) AND (grantee.oid = fdw.grantee) AND (fdw.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
        UNION ALL
         SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS object_catalog,
            (''::name)::information_schema.sql_identifier AS object_schema,
            (srv.srvname)::information_schema.sql_identifier AS object_name,
            ('FOREIGN SERVER'::character varying)::information_schema.character_data AS object_type,
            ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_foreign_server.srvname,
                    pg_foreign_server.srvowner,
                    (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).is_grantable AS is_grantable
                   FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((u_grantor.oid = srv.grantor) AND (grantee.oid = srv.grantee) AND (srv.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
        UNION ALL
         SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
            (grantee.rolname)::information_schema.sql_identifier AS grantee,
            (current_database())::information_schema.sql_identifier AS object_catalog,
            (n.nspname)::information_schema.sql_identifier AS object_schema,
            (c.relname)::information_schema.sql_identifier AS object_name,
            ('SEQUENCE'::character varying)::information_schema.character_data AS object_type,
            ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
            (
                CASE
                    WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_grantable
           FROM ( SELECT pg_class.oid,
                    pg_class.relname,
                    pg_class.relnamespace,
                    pg_class.relkind,
                    pg_class.relowner,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
                   FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
            pg_namespace n,
            pg_authid u_grantor,
            ( SELECT pg_authid.oid,
                    pg_authid.rolname
                   FROM pg_authid
                UNION ALL
                 SELECT (0)::oid AS oid,
                    'PUBLIC'::name) grantee(oid, rolname)
          WHERE ((c.relnamespace = n.oid) AND (c.relkind = 'S'::"char") AND (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)));
    - type: view
      name: user_defined_types
      columns:
      - name: user_defined_type_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: user_defined_type_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: user_defined_type_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: user_defined_type_category
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_instantiable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_final
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: ordering_form
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: ordering_category
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: ordering_routine_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordering_routine_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ordering_routine_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: reference_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: data_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: character_maximum_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_octet_length
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: character_set_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: character_set_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: collation_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: numeric_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_precision_radix
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: numeric_scale
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: datetime_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: interval_type
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: interval_precision
        datatype:
          type: information_schema.cardinal_number
          nullable: true
      - name: source_dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: ref_dtd_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS user_defined_type_catalog,
            (n.nspname)::information_schema.sql_identifier AS user_defined_type_schema,
            (c.relname)::information_schema.sql_identifier AS user_defined_type_name,
            ('STRUCTURED'::character varying)::information_schema.character_data AS user_defined_type_category,
            ('YES'::character varying)::information_schema.yes_or_no AS is_instantiable,
            (NULL::character varying)::information_schema.yes_or_no AS is_final,
            (NULL::character varying)::information_schema.character_data AS ordering_form,
            (NULL::character varying)::information_schema.character_data AS ordering_category,
            (NULL::name)::information_schema.sql_identifier AS ordering_routine_catalog,
            (NULL::name)::information_schema.sql_identifier AS ordering_routine_schema,
            (NULL::name)::information_schema.sql_identifier AS ordering_routine_name,
            (NULL::character varying)::information_schema.character_data AS reference_type,
            (NULL::character varying)::information_schema.character_data AS data_type,
            (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
            (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
            (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
            (NULL::name)::information_schema.sql_identifier AS character_set_schema,
            (NULL::name)::information_schema.sql_identifier AS character_set_name,
            (NULL::name)::information_schema.sql_identifier AS collation_catalog,
            (NULL::name)::information_schema.sql_identifier AS collation_schema,
            (NULL::name)::information_schema.sql_identifier AS collation_name,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
            (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
            (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
            (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
            (NULL::character varying)::information_schema.character_data AS interval_type,
            (NULL::integer)::information_schema.cardinal_number AS interval_precision,
            (NULL::name)::information_schema.sql_identifier AS source_dtd_identifier,
            (NULL::name)::information_schema.sql_identifier AS ref_dtd_identifier
           FROM pg_namespace n,
            pg_class c,
            pg_type t
          WHERE ((n.oid = c.relnamespace) AND (t.typrelid = c.oid) AND (c.relkind = 'c'::"char") AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)));
    - type: view
      name: user_mapping_options
      columns:
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: option_value
        datatype:
          type: information_schema.character_data
          nullable: true
      manual: true
      definition: |-
        SELECT um.authorization_identifier,
            um.foreign_server_catalog,
            um.foreign_server_name,
            (opts.option_name)::information_schema.sql_identifier AS option_name,
            (
                CASE
                    WHEN (((um.umuser <> (0)::oid) AND ((um.authorization_identifier)::name = CURRENT_USER)) OR ((um.umuser = (0)::oid) AND pg_has_role((um.srvowner)::name, 'USAGE'::text)) OR ( SELECT pg_authid.rolsuper
                       FROM pg_authid
                      WHERE (pg_authid.rolname = CURRENT_USER))) THEN opts.option_value
                    ELSE NULL::text
                END)::information_schema.character_data AS option_value
           FROM information_schema._pg_user_mappings um,
            LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value);
    - type: view
      name: user_mappings
      columns:
      - name: authorization_identifier
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: foreign_server_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT _pg_user_mappings.authorization_identifier,
            _pg_user_mappings.foreign_server_catalog,
            _pg_user_mappings.foreign_server_name
           FROM information_schema._pg_user_mappings;
    - type: view
      name: view_column_usage
      columns:
      - name: view_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: view_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: view_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: column_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
            (nv.nspname)::information_schema.sql_identifier AS view_schema,
            (v.relname)::information_schema.sql_identifier AS view_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nt.nspname)::information_schema.sql_identifier AS table_schema,
            (t.relname)::information_schema.sql_identifier AS table_name,
            (a.attname)::information_schema.sql_identifier AS column_name
           FROM pg_namespace nv,
            pg_class v,
            pg_depend dv,
            pg_depend dt,
            pg_class t,
            pg_namespace nt,
            pg_attribute a
          WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (t.oid = a.attrelid) AND (dt.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE'::text));
    - type: view
      name: view_routine_usage
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: specific_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT DISTINCT (current_database())::information_schema.sql_identifier AS table_catalog,
            (nv.nspname)::information_schema.sql_identifier AS table_schema,
            (v.relname)::information_schema.sql_identifier AS table_name,
            (current_database())::information_schema.sql_identifier AS specific_catalog,
            (np.nspname)::information_schema.sql_identifier AS specific_schema,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name
           FROM pg_namespace nv,
            pg_class v,
            pg_depend dv,
            pg_depend dp,
            pg_proc p,
            pg_namespace np
          WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dp.objid) AND (dp.classid = ('pg_rewrite'::regclass)::oid) AND (dp.refclassid = ('pg_proc'::regclass)::oid) AND (dp.refobjid = p.oid) AND (p.pronamespace = np.oid) AND pg_has_role(p.proowner, 'USAGE'::text));
    - type: view
      name: view_table_usage
      columns:
      - name: view_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: view_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: view_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      manual: true
      definition: |-
        SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
            (nv.nspname)::information_schema.sql_identifier AS view_schema,
            (v.relname)::information_schema.sql_identifier AS view_name,
            (current_database())::information_schema.sql_identifier AS table_catalog,
            (nt.nspname)::information_schema.sql_identifier AS table_schema,
            (t.relname)::information_schema.sql_identifier AS table_name
           FROM pg_namespace nv,
            pg_class v,
            pg_depend dv,
            pg_depend dt,
            pg_class t,
            pg_namespace nt
          WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND pg_has_role(t.relowner, 'USAGE'::text));
    - type: view
      name: views
      columns:
      - name: table_catalog
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_schema
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: table_name
        datatype:
          type: information_schema.sql_identifier
          nullable: true
      - name: view_definition
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: check_option
        datatype:
          type: information_schema.character_data
          nullable: true
      - name: is_updatable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_insertable_into
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_trigger_updatable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_trigger_deletable
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      - name: is_trigger_insertable_into
        datatype:
          type: information_schema.yes_or_no
          nullable: true
      manual: true
      definition: |-
        SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
            (nc.nspname)::information_schema.sql_identifier AS table_schema,
            (c.relname)::information_schema.sql_identifier AS table_name,
            (
                CASE
                    WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)
                    ELSE NULL::text
                END)::information_schema.character_data AS view_definition,
            (
                CASE
                    WHEN ('check_option=cascaded'::text = ANY (c.reloptions)) THEN 'CASCADED'::text
                    WHEN ('check_option=local'::text = ANY (c.reloptions)) THEN 'LOCAL'::text
                    ELSE 'NONE'::text
                END)::information_schema.character_data AS check_option,
            (
                CASE
                    WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_updatable,
            (
                CASE
                    WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_insertable_into,
            (
                CASE
                    WHEN (EXISTS ( SELECT 1
                       FROM pg_trigger
                      WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 81) = 81)))) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_trigger_updatable,
            (
                CASE
                    WHEN (EXISTS ( SELECT 1
                       FROM pg_trigger
                      WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 73) = 73)))) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_trigger_deletable,
            (
                CASE
                    WHEN (EXISTS ( SELECT 1
                       FROM pg_trigger
                      WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 69) = 69)))) THEN 'YES'::text
                    ELSE 'NO'::text
                END)::information_schema.yes_or_no AS is_trigger_insertable_into
           FROM pg_namespace nc,
            pg_class c
          WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));
