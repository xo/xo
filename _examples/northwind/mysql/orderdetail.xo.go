package mysql

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// OrderDetail represents a row from 'northwind.order_details'.
type OrderDetail struct {
	OrderID   int16   `json:"order_id"`   // order_id
	ProductID int16   `json:"product_id"` // product_id
	UnitPrice float32 `json:"unit_price"` // unit_price
	Quantity  int16   `json:"quantity"`   // quantity
	Discount  float32 `json:"discount"`   // discount
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [OrderDetail] exists in the database.
func (od *OrderDetail) Exists() bool {
	return od._exists
}

// Deleted returns true when the [OrderDetail] has been marked for deletion
// from the database.
func (od *OrderDetail) Deleted() bool {
	return od._deleted
}

// Insert inserts the [OrderDetail] to the database.
func (od *OrderDetail) Insert(ctx context.Context, db DB) error {
	switch {
	case od._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case od._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO northwind.order_details (` +
		`order_id, product_id, unit_price, quantity, discount` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, od.OrderID, od.ProductID, od.UnitPrice, od.Quantity, od.Discount)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID, od.UnitPrice, od.Quantity, od.Discount); err != nil {
		return logerror(err)
	}
	// set exists
	od._exists = true
	return nil
}

// Update updates a [OrderDetail] in the database.
func (od *OrderDetail) Update(ctx context.Context, db DB) error {
	switch {
	case !od._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case od._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE northwind.order_details SET ` +
		`unit_price = ?, quantity = ?, discount = ? ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, od.UnitPrice, od.Quantity, od.Discount, od.OrderID, od.ProductID)
	if _, err := db.ExecContext(ctx, sqlstr, od.UnitPrice, od.Quantity, od.Discount, od.OrderID, od.ProductID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [OrderDetail] to the database.
func (od *OrderDetail) Save(ctx context.Context, db DB) error {
	if od.Exists() {
		return od.Update(ctx, db)
	}
	return od.Insert(ctx, db)
}

// Upsert performs an upsert for [OrderDetail].
func (od *OrderDetail) Upsert(ctx context.Context, db DB) error {
	switch {
	case od._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO northwind.order_details (` +
		`order_id, product_id, unit_price, quantity, discount` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`order_id = VALUES(order_id), product_id = VALUES(product_id), unit_price = VALUES(unit_price), quantity = VALUES(quantity), discount = VALUES(discount)`
	// run
	logf(sqlstr, od.OrderID, od.ProductID, od.UnitPrice, od.Quantity, od.Discount)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID, od.UnitPrice, od.Quantity, od.Discount); err != nil {
		return logerror(err)
	}
	// set exists
	od._exists = true
	return nil
}

// Delete deletes the [OrderDetail] from the database.
func (od *OrderDetail) Delete(ctx context.Context, db DB) error {
	switch {
	case !od._exists: // doesn't exist
		return nil
	case od._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM northwind.order_details ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, od.OrderID, od.ProductID)
	if _, err := db.ExecContext(ctx, sqlstr, od.OrderID, od.ProductID); err != nil {
		return logerror(err)
	}
	// set deleted
	od._deleted = true
	return nil
}

// OrderDetailByOrderIDProductID retrieves a row from 'northwind.order_details' as a [OrderDetail].
//
// Generated from index 'order_details_order_id_product_id_pkey'.
func OrderDetailByOrderIDProductID(ctx context.Context, db DB, orderID, productID int16) (*OrderDetail, error) {
	// query
	const sqlstr = `SELECT ` +
		`order_id, product_id, unit_price, quantity, discount ` +
		`FROM northwind.order_details ` +
		`WHERE order_id = ? AND product_id = ?`
	// run
	logf(sqlstr, orderID, productID)
	od := OrderDetail{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, orderID, productID).Scan(&od.OrderID, &od.ProductID, &od.UnitPrice, &od.Quantity, &od.Discount); err != nil {
		return nil, logerror(err)
	}
	return &od, nil
}

// OrderDetailsByProductID retrieves a row from 'northwind.order_details' as a [OrderDetail].
//
// Generated from index 'product_id'.
func OrderDetailsByProductID(ctx context.Context, db DB, productID int16) ([]*OrderDetail, error) {
	// query
	const sqlstr = `SELECT ` +
		`order_id, product_id, unit_price, quantity, discount ` +
		`FROM northwind.order_details ` +
		`WHERE product_id = ?`
	// run
	logf(sqlstr, productID)
	rows, err := db.QueryContext(ctx, sqlstr, productID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*OrderDetail
	for rows.Next() {
		od := OrderDetail{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&od.OrderID, &od.ProductID, &od.UnitPrice, &od.Quantity, &od.Discount); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &od)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Order returns the Order associated with the [OrderDetail]'s (OrderID).
//
// Generated from foreign key 'order_details_ibfk_1'.
func (od *OrderDetail) Order(ctx context.Context, db DB) (*Order, error) {
	return OrderByOrderID(ctx, db, od.OrderID)
}

// Product returns the Product associated with the [OrderDetail]'s (ProductID).
//
// Generated from foreign key 'order_details_ibfk_2'.
func (od *OrderDetail) Product(ctx context.Context, db DB) (*Product, error) {
	return ProductByProductID(ctx, db, od.ProductID)
}
